# UMG, Germany 
# author: Yasas Wijesekara
# vcat : map virus reads to ICTV reference genomes

import os
import re

configfile: "config.yaml"

DBDIR  = config["database_dir"]
OUTDIR = config["output_dir"]
os.makedirs(OUTDIR, exist_ok=True)
INFILES = config["sample"]  # expected: "in=<r1>[,in2=<r2>]" (or in1=)

TMPDIR = config.get("tmpdir", f"{OUTDIR}/tmp")
os.makedirs(TMPDIR, exist_ok=True)


# Database / reference paths
REF_GENOMES = f"{DBDIR}/VMR_latest/genomes.fna"



def tool_args(key):
    return str(config.get(key) or "").strip()


def sample_from_fastq(path):
    name = os.path.basename(path)
    name = re.sub(r"\.(fastq|fq)(\.gz)?$", "", name)   # drop .fastq/.fq(.gz)
    name = re.sub(r"([._-])R?[12]$", "", name)         # drop _R1/_R2/.1/.2 etc
    return name


def parse_infiles(infiles_str):
    """
    Parse config['sample'] of the form:
      "in=/path/R1.fastq.gz"
      "in=/path/R1.fastq.gz,in2=/path/R2.fastq.gz"
      also supports: in1=/path/R1.fastq.gz
    Returns (r1_path, r2_path_or_None)
    """
    r1 = r2 = None
    for part in str(infiles_str).split(","):
        part = part.strip()
        if part.startswith("in="):
            r1 = part[len("in="):]
        elif part.startswith("in1="):
            r1 = part[len("in1="):]
        elif part.startswith("in2="):
            r2 = part[len("in2="):]
    if not r1:
        raise ValueError("config['sample'] must contain in=<R1> (or in1=<R1>).")
    return r1, r2


R1, R2 = parse_infiles(INFILES)


def sample_name():
    s1 = sample_from_fastq(R1)
    if R2:
        s2 = sample_from_fastq(R2)
        if s1 != s2:
            raise ValueError(f"Provided read pairs have different sample names: {s1} vs {s2}")
    return s1


SAMPLE = sample_name()


def bbmap_in_params():
    # BBMap uses in= for SE, in1=/in2= for PE
    if R2:
        return f"in1={R1} in2={R2}"
    return f"in={R1}"


rule all:
    input:
        f"{OUTDIR}/{SAMPLE}.sorted.bam",
        f"{OUTDIR}/{SAMPLE}.sorted.bam.bai",
        f"{OUTDIR}/{SAMPLE}.pileup.tsv"


rule map_reads:
    input:
        ref=REF_GENOMES
    output:
        sam=temp(f"{TMPDIR}/{{sample}}.sam")
    params:
        bbmap_args=lambda wc: (config.get("bbmap_args") or " "), # None or " "
        bbmap_in=lambda wc: bbmap_in_params(),
        bbmap_index_path=TMPDIR
    threads: int(workflow.cores * 0.75)
    shell:
        r"""
        bbmap.sh ref={input.ref} {params.bbmap_in} out={output.sam} path={params.bbmap_index_path} {params.bbmap_args}
        """


rule sort_bam:
    input:
        sam=f"{TMPDIR}/{{sample}}.sam"
    output:
        bam=f"{OUTDIR}/{{sample}}.sorted.bam"
    threads: int(workflow.cores * 0.75)
    shell:
        r"""
        samtools sort -@ {threads} -o {output.bam} {input.sam}
        """


rule index_bam:
    input:
        bam=f"{OUTDIR}/{{sample}}.sorted.bam"
    output:
        bai=f"{OUTDIR}/{{sample}}.sorted.bam.bai"
    shell:
        r"""
        samtools index {input.bam} {output.bai}
        """

rule pileup:
    input:
        bam=f"{OUTDIR}/{{sample}}.sorted.bam"
    output:
        tsv=f"{OUTDIR}/{{sample}}.pileup.tsv"
    params:
        pileup_args=lambda wc: tool_args("pileup_args")
    shell:
        r"""
        pileup.sh \
          in={input.bam} \
          out={output.tsv} \
          {params.pileup_args}
        """

rule summarize:
    input:
        tsv=f"{OUTDIR}/{{sample}}.pileup.tsv"
    output:
        tsv=f"{OUTDIR}/{{sample}}.vcat.tsv"
    params:
        database_dir = DBDIR,
        summary_args=lambda wc: tool_args("summary_args")
    shell:
        r"""
        read_mapping_summary.py -i {input.tsv} -o {output.tsv} -d {params.database_dir} {params.summary_args}
        """